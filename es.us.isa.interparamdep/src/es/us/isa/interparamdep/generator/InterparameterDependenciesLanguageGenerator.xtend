/*
 * generated by Xtext 2.19.0
 */
package es.us.isa.interparamdep.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.EObject

import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import es.us.isa.interparamdep.interparameterDependenciesLanguage.Dependency;
import es.us.isa.interparamdep.interparameterDependenciesLanguage.ConditionalDependency;
import es.us.isa.interparamdep.interparameterDependenciesLanguage.impl.ArithmeticDependencyImpl
import es.us.isa.interparamdep.interparameterDependenciesLanguage.impl.ConditionalDependencyImpl
import es.us.isa.interparamdep.interparameterDependenciesLanguage.impl.PredefinedDependencyImpl

import java.nio.file.Files
import java.nio.file.Paths
import java.util.Arrays
import java.nio.charset.StandardCharsets
import java.nio.file.StandardOpenOption
import java.io.File
import java.nio.file.Path

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class InterparameterDependenciesLanguageGenerator extends AbstractGenerator {
	
	val String path = System.getProperty("user.home") + "/output.txt"
	val File file = new File(path)
	val Path writePath = Paths.get(path)

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		file.delete
		file.createNewFile
		
		for (dependency: resource.allContents.filter(Dependency).toIterable) {
			solveDependencyAndOrIterate(dependency.dep, 0, 0)
	    	Files.write(writePath, Arrays.asList("....................."),
		    	StandardCharsets.UTF_8, StandardOpenOption.APPEND)
		    for (subElement: dependency.eAllContents.toIterable) {
		    	Files.write(writePath, Arrays.asList(subElement.toString),
		    		StandardCharsets.UTF_8, StandardOpenOption.APPEND)
		    }
		    Files.write(writePath, Arrays.asList("---------------------"),
		    	StandardCharsets.UTF_8, StandardOpenOption.APPEND)
		}
	}
	
	def void solveDependencyAndOrIterate(EObject object, int depthLevel, int objectDepthLevel) {
		if (object.class == typeof(ConditionalDependencyImpl)) {
			Files.write(writePath, Arrays.asList("("+ depthLevel + ", " + objectDepthLevel + ") - Conditional dependency: " + object),
	    		StandardCharsets.UTF_8, StandardOpenOption.APPEND)
	    	Files.write(writePath, Arrays.asList("("+ depthLevel + ", " + objectDepthLevel + ") - Condition"),
	    		StandardCharsets.UTF_8, StandardOpenOption.APPEND)
    		solveDependencyAndOrIterate((object as ConditionalDependency).condition, depthLevel+1, objectDepthLevel+1)
	    	Files.write(writePath, Arrays.asList("("+ depthLevel + ", " + objectDepthLevel + ") - Consequence"),
	    		StandardCharsets.UTF_8, StandardOpenOption.APPEND)
    		solveDependencyAndOrIterate((object as ConditionalDependency).consequence, depthLevel+1, objectDepthLevel+1)
		} else if (object.class == typeof(ArithmeticDependencyImpl)) {
			Files.write(writePath, Arrays.asList("("+ depthLevel + ", " + objectDepthLevel + ") - Arithmetic dependency: " + object),
    			StandardCharsets.UTF_8, StandardOpenOption.APPEND)
		} else if (object.class == typeof(PredefinedDependencyImpl)) {
			Files.write(writePath, Arrays.asList("("+ depthLevel + ", " + objectDepthLevel + ") - Predefined dependency: " + object),
	    		StandardCharsets.UTF_8, StandardOpenOption.APPEND)
	    	for (element: object.eContents) {
	    		solveDependencyAndOrIterate(element, depthLevel+1, objectDepthLevel+1)
	    	}
		} else {
			Files.write(writePath, Arrays.asList("("+ depthLevel + ", " + objectDepthLevel + ") - Object: " + object),
	    			StandardCharsets.UTF_8, StandardOpenOption.APPEND)
			for (subElement: object.eContents) {
				solveDependencyAndOrIterate(subElement, depthLevel, objectDepthLevel+1)
			}
		}
	}
	
	// Solving a dependency means returning 'true' or 'false'. In the case of a
	// conditional dependency, the consequence should only be evaluated if the
	// condition returns true
	
	/*
	 * Since the arithmetic dependency cannot nest any other dependencies, its
	 * solving stops after the CSP mapping, i.e. there's no need to iterate over
	 * other possibly nested dependencies
	 */
	def boolean solveArithmeticDependency() {
		// TODO: Implement CSP mapping
		
		return true
	}
	
	def boolean solvePredefinedDependency() {
		// TODO: Implement CSP mapping
		
		return true
	}
	
	def boolean solveConditionalDependency() {
		// TODO: Implement CSP mapping
		
		return true
	}
	
	def boolean solveLogicalClause() {
		// TODO: Implement CSP mapping
		
		return true
	}
	
	
	
	
	
	
}






